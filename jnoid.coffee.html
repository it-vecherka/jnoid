<!DOCTYPE html>

<html>
<head>
  <title>Jnoid</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="README.html">
                README.md
              </a>
            
              
              <a class="source" href="simple.coffee.html">
                simple.coffee.md
              </a>
            
              
              <a class="source" href="jnoid.coffee.html">
                jnoid.coffee.md
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Jnoid</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>This is a functional reactive programming library in Coffescript to use in
browser or Node.js applications. It owes the idea to Bacon.js, but should
describe the domain in proper terms, have less operations in primitives and be
shorter and simpler.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Jnoid = {
  VERSION: <span class="string">"0.0.1"</span>
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The core idea is having an abstraction of <code>Stream</code> which is a discrete
sequence of values and an abstraction of a <code>Box</code> which is a continous
time-varying value, both of which you can subscribe on.</p>
<h2>Maybe and Events</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>We&#39;ll slightly extend the famous <code>Maybe</code> idiom to support error values. Now
it&#39;s a sum of <code>Maybe</code> and <code>Either</code> and can be described as <code>Maybe = Just x |
Wrong y | Nothing</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">Maybe</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">Just</span> <span class="keyword">extends</span> <span class="title">Maybe</span></span>
  constructor: (<span class="property">@value</span>) -&gt;
  getOrElse: -&gt; <span class="property">@value</span>
  filter: (f) -&gt; <span class="keyword">if</span> <span class="property">@test</span>(f) <span class="keyword">then</span> @ <span class="keyword">else</span> Nothing
  test: (f) -&gt; f <span class="property">@value</span>
  map: (f) -&gt; <span class="keyword">new</span> Just(f <span class="property">@value</span>)
  isEmpty: -&gt; <span class="literal">false</span>
  inspect: -&gt; <span class="string">"Just <span class="subst">#{@value}</span>"</span>

<span class="class"><span class="keyword">class</span> <span class="title">Bad</span> <span class="keyword">extends</span> <span class="title">Maybe</span></span>
  getOrElse: (some)-&gt; some
  filter: (f) -&gt; @
  test: (f) -&gt; <span class="literal">true</span>
  map: (f) -&gt; @
  isEmpty: -&gt; <span class="literal">true</span>

<span class="class"><span class="keyword">class</span> <span class="title">Wrong</span> <span class="keyword">extends</span> <span class="title">Bad</span></span>
  constructor: (<span class="property">@error</span>) -&gt;
  inspect: -&gt; <span class="string">"Wrong <span class="subst">#{@error}</span>"</span>

Nothing = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Bad</span></span>
  constructor: -&gt;
  inspect: -&gt; <span class="string">"Nothing"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p><code>Event</code> class will be just a type alias for it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>[Event, Fire, Error, Stop] = [Maybe, Just, Wrong, Nothing]
<span class="function"><span class="title">toEvent</span></span> = (x) -&gt; <span class="keyword">if</span> x <span class="keyword">instanceof</span> Event <span class="keyword">then</span> x <span class="keyword">else</span> <span class="keyword">new</span> Fire x
<span class="function"><span class="title">toError</span></span> = (x) -&gt; <span class="keyword">if</span> x <span class="keyword">instanceof</span> Event <span class="keyword">then</span> x <span class="keyword">else</span> <span class="keyword">new</span> Error x</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2>Observable</h2>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The point is that we can abstract from <code>Stream</code> and <code>Box</code> and define a common
behavior, calling it <code>Observable</code>.</p>
<p>Class <code>Observable</code> will be determined via a <code>subscribe</code> function. This
function should receive a subscriber or sink function as an argument and
call it whenever event is fired. This enables push semantics for <code>Stream</code>
and <code>Box</code>.</p>
<p>There are two ways to unsubscribe. First is to call function that subscribe
returns. Second is return <code>Reply.stop</code> from event listener.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">Observable</span></span>
  constructor: (subscribe)-&gt;
    <span class="property">@subscribe</span> = <span class="property">@dispatched</span> subscribe</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><code>dispathed</code> is a function that makes <code>Observable</code> abstract and will hold the
actual implementation differences between <code>Stream</code> and <code>Box</code>. If you are
interested in <code>dispatched</code>, check it&#39;s implementations there.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  dispatched: fail</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>A basic ways to listen to Observable are <code>onValue</code> and <code>onError</code>. While
<code>subscribe</code> sends raw events, <code>onValue</code> unwraps them in case they hold values
and deliver them to the subscriber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  onValue: (f) -&gt;
    <span class="property">@subscribe</span> (event) -&gt;
      event.map((v)-&gt; f(v)).getOrElse(Reply.more)</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><code>onError</code> does roughly the same as <code>onValue</code>, but is selecting errors and
unwraps them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  onError: (f) -&gt;
    <span class="property">@subscribe</span> (event) -&gt;
      <span class="keyword">if</span> event <span class="keyword">instanceof</span> Error
        f event.error
      <span class="keyword">else</span>
        Reply.more</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>We can now define basic transforms. Start with <code>map</code> and <code>filter</code>. We can
see common pattern there, it&#39;s abstracted in <code>withHandler</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  withHandler: (handler)-&gt;
    <span class="keyword">new</span> <span class="property">@constructor</span> <span class="property">@dispatched</span>(<span class="property">@subscribe</span>, handler)

  map: (f)-&gt;
    <span class="property">@withHandler</span> (event)-&gt; <span class="property">@push</span> event.map(f)

  filter: (f)-&gt;
    <span class="property">@withHandler</span> (event)-&gt; <span class="keyword">if</span> event.test(f) <span class="keyword">then</span> <span class="property">@push</span> event <span class="keyword">else</span> Reply.more</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>A useful combinator is <code>recover</code>, with will turn errors into regular
events using transform function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  recover: (f)-&gt;
    <span class="property">@withHandler</span> (event) -&gt;
      <span class="keyword">if</span> event <span class="keyword">instanceof</span> Error
        <span class="property">@push</span> <span class="keyword">new</span> Fire f(event.error)
      <span class="keyword">else</span>
        <span class="property">@push</span> event</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The most powerful combinator in our case is <code>flatMap</code>. It accepts a function
that turns each of the values in observable to a new observable. We then return
a new Observable that will combine them.</p>
<p>The first way to combine them is to just collect all the events from the
spawned childen. This matches the semantics of <code>Stream</code> and will allow us to
produce merge.</p>
<p>Another way to combine events is to unsubscribe all the existing children, when
a new event occurs on root, then spawn a new one and just listen to it. You can
think of it as swiching from one observable to another one. This matches the
semantics of <code>Box</code> and will allow us to produce <code>zip</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMapGeneric: (f, lastOnly) -&gt;
    root = <span class="keyword">this</span>
    <span class="keyword">new</span> <span class="property">@constructor</span> (sink) -&gt;
      children = []
      rootStop = <span class="literal">false</span>
      <span class="function"><span class="title">unsubRoot</span></span> = -&gt;
      <span class="function"><span class="title">unsubChildren</span></span> = -&gt;
        unsubChild() <span class="keyword">for</span> unsubChild <span class="keyword">in</span> children
        children = []
      <span class="function"><span class="title">unbind</span></span> = -&gt;
        unsubChildren()
        unsubRoot()
      <span class="function"><span class="title">checkStop</span></span> = -&gt;
        <span class="keyword">if</span> rootStop <span class="keyword">and</span> (children.length == <span class="number">0</span>)
          sink Stop
      <span class="function"><span class="title">spawner</span></span> = (event) -&gt;
        <span class="keyword">if</span> event == Stop
          rootStop = <span class="literal">true</span>
          checkStop()
        <span class="keyword">else</span>
          unsubChildren() <span class="keyword">if</span> lastOnly
          <span class="keyword">if</span> event <span class="keyword">instanceof</span> Error
            sink event
          <span class="keyword">else</span>
            child = f event.value
            unsubChild = <span class="literal">undefined</span>
            childStopped = <span class="literal">false</span>
            <span class="function"><span class="title">removeChild</span></span> = -&gt;
              remove(unsubChild, children) <span class="keyword">if</span> unsubChild?
              checkStop()
            <span class="function"><span class="title">handler</span></span> = (event) -&gt;
              <span class="keyword">if</span> event == Stop
                removeChild()
                childStopped = <span class="literal">true</span>
                Reply.stop
              <span class="keyword">else</span>
                tap sink(event), (reply)-&gt;
                  unbind() <span class="keyword">if</span> reply == Reply.stop
            unsubChild = child.subscribe handler
            children.push unsubChild <span class="keyword">if</span> <span class="keyword">not</span> childStopped
      unsubRoot = root.subscribe(spawner)
      unbind

  flatMapAll: (f)-&gt; <span class="property">@flatMapGeneric</span>(f, <span class="literal">false</span>)
  flatMapLast: (f)-&gt; <span class="property">@flatMapGeneric</span>(f, <span class="literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>We can also define <code>skipDuplicates</code> which is extremely useful.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  withStateMachine: (initState, f) -&gt;
    state = initState
    <span class="property">@withHandler</span> (event) -&gt;
      [newState, outputs] = f(state, event)
      state = newState
      stopped = any outputs,
                (output)=&gt; <span class="property">@push</span>(output) == Reply.stop
      <span class="keyword">if</span> stopped <span class="keyword">then</span> Reply.stop <span class="keyword">else</span> Reply.more

  skipDuplicates: (<span class="function"><span class="title">isEqual</span></span> = (a, b) -&gt; a <span class="keyword">is</span> b) -&gt;
    <span class="property">@withStateMachine</span> Nothing, (prev, event) -&gt;
      event.map((v)-&gt;
        <span class="keyword">if</span> prev == Nothing || !prev.test((p)-&gt; isEqual(v, p))
          [<span class="keyword">new</span> Just(v), [event]]
        <span class="keyword">else</span>
          [prev, []]
      ).getOrElse [prev, [event]]</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2>How to build observables</h2>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>The basic ways to build an observable are <code>nothing</code>, <code>unit</code> and <code>error</code>. In
<code>Stream</code> semantics they mean <code>never</code>, <code>once</code> and <code>error</code>, in <code>Box</code> semantics
they mean <code>empty</code>, <code>always</code> and <code>error</code>. We won&#39;t create the aliases and give
these names to get you the feel of what they mean.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="property">@fromList</span>: (values, wrapper = toEvent)-&gt;
    <span class="keyword">new</span> @ (sink) -&gt;
      sink event <span class="keyword">for</span> event <span class="keyword">in</span> map wrapper, values
      sink Stop

  <span class="property">@nothing</span>: -&gt; <span class="property">@fromList</span> []
  <span class="property">@unit</span>: (value)-&gt; <span class="property">@fromList</span> [value]
  <span class="property">@error</span>: (value)-&gt; <span class="property">@fromList</span> [value], toError</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p><code>fromBinder</code> just adds a syntax sugar for us to easily define more
sophisticated constructors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="property">@fromBinder</span>: (binder, transform = id) -&gt;
    <span class="keyword">new</span> @ (sink) -&gt;
      unbinder = binder (args...) -&gt;
        events = toArray transform args...
        <span class="keyword">for</span> event <span class="keyword">in</span> map toEvent, events
          tap sink(event), (reply)-&gt;
            unbinder() <span class="keyword">if</span> event == Stop <span class="keyword">or</span> reply == Reply.stop</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><code>poll</code> polls a function within given interval.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="property">@poll</span>: (delay, poll) -&gt;
    <span class="property">@fromBinder</span> (handler) -&gt;
      i = setInterval(handler, delay)
      -&gt; clearInterval(i)
    , poll</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><code>interval</code> and <code>later</code> send a fixed list of events or one event
respectively within given interval.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="property">@interval</span>: (delay, list)-&gt;
    index = <span class="number">0</span>
    <span class="property">@poll</span> delay, -&gt;
      value = list[index++]
      <span class="keyword">if</span> index &lt; list.length
        value
      <span class="keyword">else</span> <span class="keyword">if</span> index == list.length
        [value, Stop]
      <span class="keyword">else</span>
        Stop

  <span class="property">@later</span>: (delay, value)-&gt;
    <span class="property">@interval</span>(delay, [value])</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Let&#39;s also define a function that works on promises, e.g., ajax. The
resource releasing here for ajax is abort. We should also handle promise
errors here. In a transform function we attach end to our stream.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="property">@fromPromise</span>: (promise) -&gt;
    <span class="property">@fromBinder</span> (handler) -&gt;
      promise.<span class="keyword">then</span> handler, (e) -&gt;
        handler <span class="keyword">new</span> Error e
      -&gt; promise.abort?()
    , (value) -&gt; [value, Stop]</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Finally let&#39;s define the way to receive events from DOM objects. We&#39;ll do
it assuming we&#39;re called in jQuery/Zepto fashion.</p>
<p>We allow to override <code>transform</code> - by default it&#39;ll take the first
argument, which is usually a jQuery event. We use <code>on</code> to subscribe and
<code>off</code> to unsubscribe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="property">@fromDOM</span>: (element, event, selector, transform) -&gt;
    [transform, selector] = [selector, <span class="literal">null</span>] <span class="keyword">if</span> isFunction(selector)

    <span class="property">@fromBinder</span> (handler) =&gt;
      element.<span class="literal">on</span>(event, selector, handler)
      =&gt; element.<span class="literal">off</span>(event, selector, handler)
    , transform</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2>Stream</h2>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Class <code>Stream</code> represents a disrete sequence of values, coupled with time.  So
it uses the appropriate dispatcher to do it.</p>
<p><code>Dispatcher</code> activates the listeners when a first sink is added and then just
adds them. On each event it just pushes it to all sinks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">StreamDispatcher</span></span>
  constructor: (subscribe, handler) -&gt;
    subscribe ?= (event) -&gt;
    sinks = []
    <span class="property">@push</span> = (event) =&gt;
      <span class="keyword">for</span> sink <span class="keyword">in</span> sinks
        tap sink(event), (reply)-&gt;
          remove sink, sinks <span class="keyword">if</span> reply == Reply.stop
    handler ?= (event) -&gt; <span class="property">@push</span> event
    <span class="property">@handler</span> = (event) =&gt; handler.apply(<span class="keyword">this</span>, [event])
    <span class="property">@subscribe</span> = (sink) =&gt;
      sinks.push(sink)
      unsubSelf = subscribe <span class="property">@handler</span> <span class="keyword">if</span> sinks.length == <span class="number">1</span>
      -&gt;
        remove sink, sinks
        unsubSelf?() <span class="keyword">unless</span> any sinks</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>To have <code>Stream</code> class we just need to override abstract <code>dispatched</code> method
from the base class to use <code>StreamDispatcher</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">Stream</span> <span class="keyword">extends</span> <span class="title">Observable</span></span>
  dispatched: (subscribe, handler)-&gt;
    <span class="keyword">new</span> StreamDispatcher(subscribe, handler).subscribe</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>For this class we can have <code>flatMap</code> aka <code>bind</code>. In our case it&#39;s <code>flatMapAll</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (args...)-&gt; <span class="property">@flatMapAll</span>(args...)</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Having this we can easily have <code>merge</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  merge: (others...)-&gt;
    Stream.fromList(map method(<span class="string">"changes"</span>), [@, others...]).flatten()
  flatten: -&gt; <span class="property">@flatMap</span>(id)</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h2>Using Stream when we need Box</h2>

            </div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>To make it transparent for a user, is this stream or box, we proxy the box
methods to box. First we define a conversion method with an optional starting
value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  box: (initial = Nothing)-&gt;
    initial = toMaybe(initial)
    <span class="keyword">new</span> Box (sink)=&gt;
      sink initial <span class="keyword">unless</span> initial.isEmpty()
      <span class="property">@subscribe</span> (event)-&gt; sink event
  changes: -&gt; @</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>We could also define a new stream with initial value merged to the beginning,
but the current code is simple enough.</p>
<p>All proxy methods are trivial.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  zipWith: (others..., f)-&gt; <span class="property">@box</span>().zipWith(others..., f)
  <span class="keyword">and</span>: (others...)-&gt; <span class="property">@box</span>().<span class="keyword">and</span>(others...)
  <span class="keyword">or</span>: (others...)-&gt; <span class="property">@box</span>().<span class="keyword">or</span>(others...)
  <span class="keyword">not</span>: -&gt; <span class="property">@box</span>().<span class="keyword">not</span>()</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h2>Box</h2>

            </div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Class <code>Box</code> represents continuous value that changes with time. So we need a
slightly tweaked dispatcher. The difference is that it holds the current
value and sends it to each new subscriber. Another difference is that even when
the Box is ended, it still sends the last value and then immediately sends stop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">BoxDispatcher</span> <span class="keyword">extends</span> <span class="title">StreamDispatcher</span></span>
  constructor: (subscribe, handler) -&gt;
    <span class="keyword">super</span> subscribe, handler
    current = Nothing
    push = <span class="property">@push</span>
    subscribe = <span class="property">@subscribe</span>
    stopped = <span class="literal">false</span>

    <span class="property">@push</span> = (event) =&gt;
      event.map((x) -&gt; current = <span class="keyword">new</span> Just x)
      stopped = <span class="literal">true</span> <span class="keyword">if</span> event == Stop
      push.apply(<span class="keyword">this</span>, [event])
    <span class="property">@subscribe</span> = (sink) =&gt;
      reply = current.map((v)-&gt; sink <span class="keyword">new</span> Fire v)
      <span class="keyword">if</span> reply.getOrElse(Reply.more) == Reply.stop
        nop
      <span class="keyword">else</span> <span class="keyword">if</span> stopped
        sink Stop
        nop
      <span class="keyword">else</span>
        subscribe.apply(@, [sink])</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Now class <code>Box</code> is going to use that dispatcher.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">Box</span> <span class="keyword">extends</span> <span class="title">Observable</span></span>
  dispatched: (subscribe, handler)-&gt;
    <span class="keyword">new</span> BoxDispatcher(subscribe, handler).subscribe</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>For this class we can have <code>flatMap</code> aka <code>bind</code>. In our case it&#39;s <code>flatMapLast</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  flatMap: (args...)-&gt; <span class="property">@flatMapLast</span>(args...)</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>With this <code>flatMap</code> we can define a glorious <code>map2</code>, also known as <code>zipWith</code>
for two boxes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  map2: (other, f)-&gt;
    <span class="property">@flatMap</span> (x)-&gt; other.box().map (y)-&gt; f(x, y)</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Having this, <code>zipWith</code> is easy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="property">@sequence</span>: (boxes)-&gt;
    foldl boxes, <span class="property">@unit</span>([]), (acc, box)-&gt;
      acc.map2 box, (memo, value)-&gt; append memo, value
  <span class="property">@zipWith</span>: (boxes, f)-&gt;
    <span class="property">@sequence</span>(boxes).map uncurry f
  zipWith: (others..., f)-&gt;
    Box.zipWith [@, others...], f</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Helpful would be to define boolean algebra over boxes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">and</span>: (others...)-&gt; <span class="property">@zipWith</span> others..., (a, b)-&gt; a &amp;&amp; b
  <span class="keyword">or</span>: (others...)-&gt; <span class="property">@zipWith</span> others..., (a, b)-&gt; a || b
  <span class="keyword">not</span>: -&gt; <span class="property">@map</span> (x)-&gt; !x</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h2>Using Box when we need Stream</h2>

            </div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>To convert <code>Box</code> into <code>Stream</code> we take it&#39;s changes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  changes: -&gt;
    <span class="keyword">new</span> Stream (sink)=&gt;
      <span class="property">@subscribe</span> (event)-&gt; sink event
  box: -&gt; @</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Here are the proxy methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  merge: (others...)-&gt; <span class="property">@changes</span>().merge(others...)</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h2>Helpers</h2>

            </div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Pretty trivial special values to return from event listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Reply =
  stop: <span class="string">"&lt;stop&gt;"</span>
  more: <span class="string">"&lt;more&gt;"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>We need some simple helper functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">empty</span></span> = (xs)-&gt; xs.length == <span class="number">0</span>
<span class="function"><span class="title">method</span></span> = (meth)-&gt; (obj)-&gt; obj[meth]()
<span class="function"><span class="title">nop</span></span> = -&gt;
<span class="function"><span class="title">id</span></span> = (x)-&gt; x
<span class="function"><span class="title">fail</span></span> = -&gt; <span class="keyword">throw</span> <span class="string">"method not implemented"</span>
<span class="function"><span class="title">head</span></span> = (xs) -&gt; xs[<span class="number">0</span>]
<span class="function"><span class="title">tail</span></span> = (xs) -&gt; xs[<span class="number">1.</span>..xs.length]
<span class="function"><span class="title">uncurry</span></span> = (f) -&gt; (args)-&gt; f(args...)
<span class="function"><span class="title">map</span></span> = (f, xs) -&gt; f(x) <span class="keyword">for</span> x <span class="keyword">in</span> xs
<span class="function"><span class="title">foldl</span></span> = (xs, seed, f) -&gt;
  <span class="keyword">for</span> x <span class="keyword">in</span> xs
    seed = f(seed, x)
  seed
<span class="function"><span class="title">tap</span></span> = (x, f) -&gt;
  f(x)
  x
<span class="function"><span class="title">remove</span></span> = (x, xs) -&gt;
  i = xs.indexOf(x)
  xs.splice(i, <span class="number">1</span>) <span class="keyword">if</span> i &gt;= <span class="number">0</span>
<span class="function"><span class="title">all</span></span> = (xs, f = id) -&gt;
  <span class="keyword">for</span> x <span class="keyword">in</span> xs
    <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> <span class="keyword">not</span> f(x)
  <span class="keyword">return</span> <span class="literal">true</span>
<span class="function"><span class="title">any</span></span> = (xs, f = id) -&gt;
  <span class="keyword">for</span> x <span class="keyword">in</span> xs
    <span class="keyword">return</span> <span class="literal">true</span> <span class="keyword">if</span> f(x)
  <span class="keyword">return</span> <span class="literal">false</span>
<span class="function"><span class="title">copyArray</span></span> = (xs)-&gt; xs.slice()
<span class="function"><span class="title">append</span></span> = (xs, x)-&gt; tap copyArray(xs), (copy)-&gt; copy.push x
<span class="function"><span class="title">isFunction</span></span> = (f) -&gt; <span class="keyword">typeof</span> f == <span class="string">"function"</span>
<span class="function"><span class="title">toArray</span></span> = (x) -&gt; <span class="keyword">if</span> x <span class="keyword">instanceof</span> Array <span class="keyword">then</span> x <span class="keyword">else</span> [x]
<span class="function"><span class="title">toMaybe</span></span> = (x) -&gt;
  <span class="keyword">if</span> x <span class="keyword">instanceof</span> Maybe <span class="keyword">then</span> x <span class="keyword">else</span> <span class="keyword">new</span> Just x</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h2>Exports</h2>

            </div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>We now need to make our objects usable outside.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">for</span> name, value <span class="keyword">of</span> {Stream, Box, Event, Fire, Error, Stop,
                                 Maybe, Just, Wrong, Nothing}
  Jnoid[name] = value

<span class="keyword">if</span> define?.amd
  define [], -&gt; Jnoid
<span class="keyword">else</span> <span class="keyword">if</span> module?.exports
  module.exports = Jnoid
<span class="keyword">else</span>
  <span class="property">@Jnoid</span> = Jnoid</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h2>Conclusion</h2>

            </div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Have fun!</p>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
